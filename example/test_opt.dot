digraph CFG {
	graph [fontname = "Monospace"];
	node  [fontname = "Monospace", shape=box, style=filled, margin=0.1];
	edge  [fontname = "Monospace"];
	bgcolor = "#f7f7f7";
	splines = false;

	main_entry [label="main_entry:\l $01 @u64 = alloca\l $04 @bool = call ok(5)\l $05 @u32 = cast @bool $04\l $06 @u32 = mul @u32 1, $05\l $08 @u32 = add @u32 $06, 1\l $09 @s32 = cast @u32 $08\l $11 @f32 = call test1($09, 10.5)\l $12 @f32 = mul @f32 $11, 2.01\l $14 @f32 = sub @f32 $12, 42\l $15 @u64 = cast @f32 $14\l store @u64 $15, $01\l $16 @u64 = load $01\l ret $16\l"];
	ok_entry [label="ok_entry:\l $01 @bool = alloca\l $02 @f64 = alloca\l store @f64 foo1, $02\l $03 @f64 = load $02\l $05 @bool = gth @f64 $03, 5\l if $05 then L0 else L1\l"];
	ok_entry -> L1 [label="Next"];
	ok_entry -> L0 [label="Branch"];
	L1 [label="L1:\l $07 @f64 = load $02\l $09 @bool = gth @f64 $07, 10\l if $09 then L3 else L4\l"];
	L1 -> L4 [label="Next"];
	L1 -> L3 [label="Branch"];
	L4 [label="L4:\l store @f64 21, $02\l goto L2\l"];
	L4 -> L2 [label="Next"];
	L3 [label="L3:\l store @f64 20, $02\l goto L2\l"];
	L3 -> L2 [label="Next"];
	L0 [label="L0:\l store @f64 0, $02\l goto L2\l"];
	L0 -> L2 [label="Next"];
	L2 [label="L2:\l $12 @f64 = load $02\l $13 @f32 = call test2(2, $12)\l $14 @bool = cast @f32 $13\l store @bool $14, $01\l $15 @bool = load $01\l ret $15\l"];
	test1_entry [label="test1_entry:\l $01 @f32 = alloca\l $02 @s32 = alloca\l $03 @f64 = alloca\l store @s32 foo2, $02\l store @f64 bar, $03\l $04 @s32 = load $02\l $05 @f64 = cast @s32 $04\l $06 @f64 = load $03\l $07 @bool = lth @f64 $05, $06\l if $07 then L6 else L7\l"];
	test1_entry -> L7 [label="Next"];
	test1_entry -> L6 [label="Branch"];
	L7 [label="L7:\l $13 @s32 = load $02\l $14 @f64 = cast @s32 $13\l $15 @f64 = load $03\l $16 @f64 = mul @f64 $14, $15\l $17 @f32 = cast @f64 $16\l store @f32 $17, $01\l goto test1_exit\l"];
	L7 -> test1_exit [label="Next"];
	L6 [label="L6:\l $08 @f64 = load $03\l $09 @s32 = load $02\l $10 @f64 = cast @s32 $09\l $11 @f64 = mul @f64 $08, $10\l $12 @f32 = cast @f64 $11\l store @f32 $12, $01\l goto test1_exit\l"];
	L6 -> test1_exit [label="Next"];
	test1_exit [label="test1_exit:\l $18 @f32 = load $01\l ret $18\l"];
	test2_entry [label="test2_entry:\l $01 @f32 = alloca\l $02 @s32 = alloca\l $03 @f64 = alloca\l store @s32 foo2, $02\l store @f64 bar, $03\l $04 @s32 = load $02\l $05 @f64 = cast @s32 $04\l $06 @f64 = load $03\l $07 @bool = lth @f64 $05, $06\l if $07 then L9 else L10\l"];
	test2_entry -> L10 [label="Next"];
	test2_entry -> L9 [label="Branch"];
	L10 [label="L10:\l $13 @s32 = load $02\l $14 @f64 = cast @s32 $13\l $15 @f64 = load $03\l $16 @f64 = mul @f64 $14, $15\l store @f64 $16, $03\l $17 @f64 = load $03\l $18 @f32 = cast @f64 $17\l store @f32 $18, $01\l goto test2_exit\l"];
	L10 -> test2_exit [label="Next"];
	L9 [label="L9:\l $08 @f64 = load $03\l $09 @s32 = load $02\l $10 @f64 = cast @s32 $09\l $11 @f64 = mul @f64 $08, $10\l $12 @f32 = cast @f64 $11\l store @f32 $12, $01\l goto test2_exit\l"];
	L9 -> test2_exit [label="Next"];
	test2_exit [label="test2_exit:\l $19 @f32 = load $01\l ret $19\l"];
}
