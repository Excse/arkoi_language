digraph CFG {
	graph [fontname = "Monospace"];
	node  [fontname = "Monospace", shape=box, style=filled, margin=0.1];
	edge  [fontname = "Monospace"];
	bgcolor = "#f7f7f7";
	splines = false;

	main_entry [label="fun main() @u64:\l $01 @u64 = alloca\l $02 @bool = const 1\l $03 @u32 = cast @bool $02\l $04 @f32 = const 5\l $05 @f64 = cast @f32 $04\l $06 @bool = call ok($05)\l $07 @u32 = cast @bool $06\l $08 @u32 = mul @u32 $03, $07\l $09 @bool = const 1\l $10 @u32 = cast @bool $09\l $11 @u32 = add @u32 $08, $10\l $12 @s32 = cast @u32 $11\l $13 @f32 = const 10.5\l $14 @f64 = cast @f32 $13\l $15 @f32 = call test1($12, $14)\l $16 @f32 = const 2.01\l $17 @f32 = mul @f32 $15, $16\l $18 @s32 = const 42\l $19 @f32 = cast @s32 $18\l $20 @f32 = sub @f32 $17, $19\l $21 @u64 = cast @f32 $20\l store @u64 $21, $01\l goto main_exit\l"];
	main_entry -> main_exit [label="Next"];
	main_exit [label="main_exit:\l $22 @u64 = load $01\l ret $22\l"];
	ok_entry [label="fun ok(foo1 @f64) @bool:\l $01 @bool = alloca\l $02 @f64 = alloca\l store @f64 foo1, $02\l $03 @f64 = load $02\l $04 @f32 = const 5\l $05 @f64 = cast @f32 $04\l $06 @bool = gth @f64 $03, $05\l if $06 then L0 else L1\l"];
	ok_entry -> L1 [label="Next"];
	ok_entry -> L0 [label="Branch"];
	L1 [label="L1:\l $09 @f64 = load $02\l $10 @f32 = const 10\l $11 @f64 = cast @f32 $10\l $12 @bool = gth @f64 $09, $11\l if $12 then L3 else L4\l"];
	L1 -> L4 [label="Next"];
	L1 -> L3 [label="Branch"];
	L4 [label="L4:\l $15 @f32 = const 21\l $16 @f64 = cast @f32 $15\l store @f64 $16, $02\l goto L5\l"];
	L4 -> L5 [label="Next"];
	L5 [label="L5:\l goto L2\l"];
	L5 -> L2 [label="Next"];
	L2 [label="L2:\l $17 @s32 = const 2\l $18 @f64 = load $02\l $19 @f32 = call test2($17, $18)\l $20 @bool = cast @f32 $19\l store @bool $20, $01\l goto ok_exit\l"];
	L2 -> ok_exit [label="Next"];
	L3 [label="L3:\l $13 @f32 = const 20\l $14 @f64 = cast @f32 $13\l store @f64 $14, $02\l goto L5\l"];
	L3 -> L5 [label="Next"];
	L0 [label="L0:\l $07 @f32 = const 0\l $08 @f64 = cast @f32 $07\l store @f64 $08, $02\l goto L2\l"];
	L0 -> L2 [label="Next"];
	ok_exit [label="ok_exit:\l $21 @bool = load $01\l ret $21\l"];
	test1_entry [label="fun test1(foo2 @s32, bar @f64) @f32:\l $01 @f32 = alloca\l $02 @s32 = alloca\l $03 @f64 = alloca\l store @s32 foo2, $02\l store @f64 bar, $03\l $04 @s32 = load $02\l $05 @f64 = cast @s32 $04\l $06 @f64 = load $03\l $07 @bool = lth @f64 $05, $06\l if $07 then L6 else L7\l"];
	test1_entry -> L7 [label="Next"];
	test1_entry -> L6 [label="Branch"];
	L7 [label="L7:\l $13 @s32 = load $02\l $14 @f64 = cast @s32 $13\l $15 @f64 = load $03\l $16 @f64 = mul @f64 $14, $15\l $17 @f32 = cast @f64 $16\l store @f32 $17, $01\l goto test1_exit\l"];
	L7 -> test1_exit [label="Next"];
	L6 [label="L6:\l $08 @f64 = load $03\l $09 @s32 = load $02\l $10 @f64 = cast @s32 $09\l $11 @f64 = mul @f64 $08, $10\l $12 @f32 = cast @f64 $11\l store @f32 $12, $01\l goto test1_exit\l"];
	L6 -> test1_exit [label="Next"];
	test1_exit [label="test1_exit:\l $18 @f32 = load $01\l ret $18\l"];
	test2_entry [label="fun test2(foo2 @s32, bar @f64) @f32:\l $01 @f32 = alloca\l $02 @s32 = alloca\l $03 @f64 = alloca\l store @s32 foo2, $02\l store @f64 bar, $03\l $04 @s32 = load $02\l $05 @f64 = cast @s32 $04\l $06 @f64 = load $03\l $07 @bool = lth @f64 $05, $06\l if $07 then L9 else L10\l"];
	test2_entry -> L10 [label="Next"];
	test2_entry -> L9 [label="Branch"];
	L10 [label="L10:\l $13 @s32 = load $02\l $14 @f64 = cast @s32 $13\l $15 @f64 = load $03\l $16 @f64 = mul @f64 $14, $15\l store @f64 $16, $03\l goto L11\l"];
	L10 -> L11 [label="Next"];
	L11 [label="L11:\l $17 @f64 = load $03\l $18 @f32 = cast @f64 $17\l store @f32 $18, $01\l goto test2_exit\l"];
	L11 -> test2_exit [label="Next"];
	L9 [label="L9:\l $08 @f64 = load $03\l $09 @s32 = load $02\l $10 @f64 = cast @s32 $09\l $11 @f64 = mul @f64 $08, $10\l $12 @f32 = cast @f64 $11\l store @f32 $12, $01\l goto test2_exit\l"];
	L9 -> test2_exit [label="Next"];
	test2_exit [label="test2_exit:\l $19 @f32 = load $01\l ret $19\l"];
}
